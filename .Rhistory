section_data <- read_sheet(sheet_id_section_data, sheet = "section_data") %>% as.data.frame()
section_data <- section_data[section_data$attempt_id == attempt_id, , drop = FALSE]
if (nrow(section_data) > 0) {
last_section <- section_data$section[which.max(section_data$saved_at)]
return(last_section)
}
return(NULL)
}
return(list(
create_attempt = create_attempt,
finish_attempt = finish_attempt,
grade_attempt = grade_attempt,
get_attempts = get_attempts,
save_section_data = save_section_data,
get_section_data = get_section_data,
get_last_section = get_last_section
))
}
# Use this Google Sheet as storage for the exam
exam_config(storage_provider = googlesheets_storage_provider(sheet_id, sheet_id))
attempts <- read_sheet(sheet_id_attempts, sheet = "attempts")
# Path to your service account JSON key file
json_path <- "dr-b-dashboard-project.json"
# Authenticate with Google Sheets using the service account key
gs4_auth(path = json_path)
# Google Sheet ID
sheet_id <- "1GVWNPH372M2PrY9ovqaSGbfU0tCQRP9-ih2VG6Zt670"
# Define the storage provider for Google Sheets
googlesheets_storage_provider <- function(sheet_id_attempts = sheet_id, sheet_id_section_data = sheet_id) {
# Define a function to read from Google Sheets
read_attempts <- function() {
read_sheet(sheet_id_attempts, sheet = "attempts") %>% as.data.frame()
}
# Define a function to write to Google Sheets
write_attempts <- function(data) {
sheet_write(data, sheet_id_attempts, sheet = "attempts")
}
# Create a new attempt
create_attempt <- function(user, exam_id, exam_version, seed, started_at, ...) {
attempt_id <- UUIDgenerate()
user_id <- user$user_id
row <- data.frame(
attempt_id = attempt_id,
user_id = user_id,
exam_id = exam_id,
exam_version = exam_version,
started_at = as.numeric(started_at),
seed = seed,
user_obj = serialize_object(user),
points = NA
)
current_attempts <- read_attempts()
updated_attempts <- rbind(current_attempts, row)
write_attempts(updated_attempts)
return(attempt_id)
}
# Finish an attempt
finish_attempt <- function(attempt_id, finished_at, ...) {
attempts <- read_attempts()
if (attempt_id %in% attempts$attempt_id) {
attempts$finished_at[attempts$attempt_id == attempt_id] <- as.numeric(finished_at)
write_attempts(attempts)
return(TRUE)
}
return(FALSE)
}
# Grade an attempt
grade_attempt <- function(attempt_id, points, ...) {
attempts <- read_attempts()
if (attempt_id %in% attempts$attempt_id) {
attempts$points[attempts$attempt_id == attempt_id] <- serialize_object(points)
write_attempts(attempts)
return(TRUE)
}
return(FALSE)
}
# Get attempts
get_attempts <- function(user, exam_id, exam_version, ...) {
attempts <- read_attempts()
if (!is.null(user)) {
attempts <- attempts[attempts$user_id == user$user_id, , drop = FALSE]
}
if (!is.null(exam_id)) {
attempts <- attempts[attempts$exam_id == exam_id, , drop = FALSE]
}
if (!is.null(exam_version)) {
attempts <- attempts[attempts$exam_version == exam_version, , drop = FALSE]
}
return(attempts)
}
# Save section data
save_section_data <- function(attempt_id, section, section_data, ...) {
row <- data.frame(
attempt_id = attempt_id,
section = section,
saved_at = as.numeric(Sys.time()),
section_data = serialize_object(section_data)
)
current_section_data <- read_sheet(sheet_id_section_data, sheet = "section_data") %>% as.data.frame()
updated_section_data <- rbind(current_section_data, row)
sheet_write(updated_section_data, sheet_id_section_data, sheet = "section_data")
return(TRUE)
}
# Get section data
get_section_data <- function(attempt_id, section, ...) {
section_data <- read_sheet(sheet_id_section_data, sheet = "section_data") %>% as.data.frame()
result <- section_data[section_data$attempt_id == attempt_id, , drop = FALSE]
if (!is.null(section)) {
result <- result[result$section == section, , drop = FALSE]
}
return(result)
}
# Get the last section for an attempt
get_last_section <- function(attempt_id, ...) {
section_data <- read_sheet(sheet_id_section_data, sheet = "section_data") %>% as.data.frame()
section_data <- section_data[section_data$attempt_id == attempt_id, , drop = FALSE]
if (nrow(section_data) > 0) {
last_section <- section_data$section[which.max(section_data$saved_at)]
return(last_section)
}
return(NULL)
}
return(list(
create_attempt = create_attempt,
finish_attempt = finish_attempt,
grade_attempt = grade_attempt,
get_attempts = get_attempts,
save_section_data = save_section_data,
get_section_data = get_section_data,
get_last_section = get_last_section
))
}
# Helper function to serialize objects
serialize_object <- function(object) {
rawToChar(serialize(object, NULL, ascii = TRUE))
}
# Use this Google Sheet as storage for the exam
exam_config(storage_provider = googlesheets_storage_provider(sheet_id, sheet_id))
attempts <- read_sheet(sheet_id_attempts, sheet = "attempts")
View(attempts)
colnames(attempts)
# Create a pool of connections to your SQLite database (if not already created)
db_pool <- dbPool(
drv = RSQLite::SQLite(),
dbname = "examinr-first_exam.sqlite",
minSize = 1,
maxSize = 1
)
library(DBI)
library(pool)
library(RSQLite)
library(base64enc)
library(writexl)
# Create a pool of connections to your SQLite database (if not already created)
db_pool <- dbPool(
drv = RSQLite::SQLite(),
dbname = "examinr-first_exam.sqlite",
minSize = 1,
maxSize = 1
)
# Function to retrieve all records from a specified table
get_all_records <- function(pool, table_name) {
query <- paste("SELECT * FROM", table_name)
results <- dbGetQuery(pool, query)
return(results)
}
# Retrieve all records from 'attempts' table
attempts_data <- get_all_records(db_pool, 'attempts')
# Retrieve all records from 'section_data' table
section_data <- get_all_records(db_pool, 'section_data')
# Function to decode base64 encoded data
=======
install.packages("examinr")
R.version
install.packages("remotes")
remotes::install_github("dakep/examinr")
library(examinr)
library(examinr)
knitr::opts_chunk$set(echo = TRUE)
summary(cars)
colnames(cars)
colnames(mpg)
library(mpg)
library(nycflights13)
knitr::opts_chunk$set(echo = TRUE)
View(nycflights13)
library(nycflights13)
knitr::opts_chunk$set(echo = TRUE)
View(nycflights13)
View(nycflights13)
nycflights13
nycflights13
colnames(nycflights13)
View(flights)
glimpse(flights)
install.packages("tidyverse")
install.packages("tidyverse")
glimpse(flights)
summary(flights)
source("~/.active-rstudio-document", echo=TRUE)
nrow(flights)
dim(flights)
count(flights)
library(RSQLite)
# Create an SQLite database for the exam "my_first_exam"
db_con <- dbConnect(RSQLite::SQLite(), "/var/run/examinr-my_first_exam.sqlite")
library(RSQLite)
# Create an SQLite database for the exam "my_first_exam"
db_con <- dbConnect(RSQLite::SQLite(), "examinr-my_first_exam.sqlite")
# Create the attempts table (SQLite doesn't have a UUID type)
dbExecute(db_con, 'CREATE TABLE attempts (
attempt_id   varchar(36) PRIMARY KEY,
user_id      varchar(64) NOT NULL,
exam_id      varchar(64) NOT NULL,
exam_version varchar(64) NOT NULL,
user_obj     text        NOT NULL,
seed         integer     NOT NULL,
started_at   timestamp   NOT NULL DEFAULT CURRENT_TIMESTAMP,
finished_at  timestamp,
points       text
)')
# Create an index on the attempts table
dbExecute(db_con, 'CREATE INDEX attempts_index ON attempts (user_id, exam_id, exam_version)')
# Create the section data table
dbExecute(db_con, 'CREATE TABLE section_data (
id           integer      PRIMARY KEY,
attempt_id   varchar(36)  NOT NULL,
section      varchar(64)  NOT NULL,
saved_at     timestamp    NOT NULL DEFAULT CURRENT_TIMESTAMP,
section_data text
)')
# Create an index on the section data table
dbExecute(db_con, 'CREATE INDEX section_data_index ON section_data (attempt_id, section)')
library(examinr)
knitr::opts_chunk$set(echo = FALSE)
#! context="server-start"
library(pool)
# Create a pool of connections to your SQLite database.
# Important: minSize and maxSize must be 1, as SQLite does not support more than one connection!
db_pool <- dbPool(drv = RSQLite::SQLite(),
dbname = "/var/run/examinr-my_first_exam.sqlite",
minSize = 1,
maxSize = 1)
library(examinr)
knitr::opts_chunk$set(echo = FALSE)
#! context="server-start"
library(pool)
# Create a pool of connections to your SQLite database.
# Important: minSize and maxSize must be 1, as SQLite does not support more than one connection!
db_pool <- dbPool(drv = RSQLite::SQLite(),
dbname = "examinr-my_first_exam.sqlite",
minSize = 1,
maxSize = 1)
# Close all connections in the pool shiny stops
shiny::onStop(function () { poolClose(db_pool) })
# Use this database as storage for the exam
exam_config(storage_provider = dbi_storage_provider(db_pool, 'attempts', 'section_data'))
library(RSQLite)
# Create an SQLite database for the exam "my_first_exam"
db_con <- dbConnect(RSQLite::SQLite(), "examinr-my_first_exam.sqlite")
# Create the attempts table (SQLite doesn't have a UUID type)
dbExecute(db_con, 'CREATE TABLE attempts (
attempt_id   varchar(36) PRIMARY KEY,
user_id      varchar(64) NOT NULL,
exam_id      varchar(64) NOT NULL,
exam_version varchar(64) NOT NULL,
user_obj     text        NOT NULL,
seed         integer     NOT NULL,
started_at   timestamp   NOT NULL DEFAULT CURRENT_TIMESTAMP,
finished_at  timestamp,
points       text
)')
rmarkdown::run("Exam1.Rmd")
rmarkdown::run("Exam1.Rmd")
rmarkdown::render("Exam1.Rmd")
install.packages("DBI")
install.packages("RSQLite")
install.packages("pool")
install.packages("pool")
library(examinr)
library(DBI)
library(RSQLite)
library(pool)
knitr::opts_chunk$set(echo = FALSE)
# Connect to the database
con <- dbConnect(RSQLite::SQLite(), "examinr-first_exam.sqlite")
results <- dbGetQuery(con, "SELECT * FROM exam_answers WHERE exam_id = 'Exam1'")
library(DBI)
library(pool)
# Assuming db_pool is already created as in your code
# db_pool <- dbPool(drv = RSQLite::SQLite(), dbname = "examinr-first_exam.sqlite")
# Function to check attempts
check_attempts <- function(exam_id) {
query <- paste("SELECT * FROM attempts WHERE exam_id = '", exam_id, "'", sep = "")
results <- dbGetQuery(db_pool, query)
return(results)
}
# Function to check section data
check_section_data <- function(attempt_id) {
query <- paste("SELECT * FROM section_data WHERE attempt_id = '", attempt_id, "'", sep = "")
results <- dbGetQuery(db_pool, query)
return(results)
}
# Example usage
attempts <- check_attempts('online-exam-with-examinr')
print(attempts)
# Replace 'your_attempt_id' with the actual attempt ID
section_data <- check_section_data('your_attempt_id')
print(section_data)
library(DBI)
library(pool)
# Assuming db_pool is already created as in your code
# db_pool <- dbPool(drv = RSQLite::SQLite(), dbname = "examinr-first_exam.sqlite")
# Function to check attempts
check_attempts <- function(exam_id) {
query <- paste("SELECT * FROM attempts WHERE exam_id = '", exam_id, "'", sep = "")
results <- dbGetQuery(db_pool, query)
return(results)
}
# Function to check section data
check_section_data <- function(attempt_id) {
query <- paste("SELECT * FROM section_data WHERE attempt_id = '", attempt_id, "'", sep = "")
results <- dbGetQuery(db_pool, query)
return(results)
}
# Example usage
attempts <- check_attempts('online-exam-with-examinr')
print(attempts)
# Replace 'your_attempt_id' with the actual attempt ID
section_data <- check_section_data('1')
print(section_data)
library(DBI)
library(pool)
# Assuming db_pool is already created as in your code
# db_pool <- dbPool(drv = RSQLite::SQLite(), dbname = "examinr-first_exam.sqlite")
# Function to check attempts
check_attempts <- function(exam_id) {
query <- paste("SELECT * FROM attempts WHERE exam_id = '", exam_id, "'", sep = "")
results <- dbGetQuery(db_pool, query)
return(results)
}
# Function to check section data
check_section_data <- function(attempt_id) {
query <- paste("SELECT * FROM section_data WHERE attempt_id = '", attempt_id, "'", sep = "")
results <- dbGetQuery(db_pool, query)
return(results)
}
# Example usage
attempts <- check_attempts('online-exam-with-examinr')
print(attempts)
# Replace 'your_attempt_id' with the actual attempt ID
section_data <- check_section_data('e5f02283-65af-4310-8cef-606a25243b17')
print(section_data)
library(DBI)
library(pool)
# Assuming db_pool is already created as in your code
# db_pool <- dbPool(drv = RSQLite::SQLite(), dbname = "examinr-first_exam.sqlite")
# Function to check attempts
check_attempts <- function(exam_id) {
query <- paste("SELECT * FROM attempts WHERE exam_id = '", exam_id, "'", sep = "")
results <- dbGetQuery(db_pool, query)
return(results)
}
# Function to check section data
check_section_data <- function(attempt_id) {
query <- paste("SELECT * FROM section_data WHERE attempt_id = '", attempt_id, "'", sep = "")
results <- dbGetQuery(db_pool, query)
return(results)
}
# Example usage
attempts <- check_attempts('online-exam-with-examinr')
print(attempts)
# Replace 'your_attempt_id' with the actual attempt ID
section_data <- check_section_data('e5f02283-65af-4310-8cef-606a25243b17')
print(section_data)
library(DBI)
library(pool)
# Assuming db_pool is already created as in your code
# db_pool <- dbPool(drv = RSQLite::SQLite(), dbname = "examinr-first_exam.sqlite")
# Function to check attempts
check_attempts <- function(exam_id) {
query <- paste("SELECT * FROM attempts WHERE exam_id = '", exam_id, "'", sep = "")
results <- dbGetQuery(db_pool, query)
return(results)
}
# Function to check section data
check_section_data <- function(attempt_id) {
query <- paste("SELECT * FROM section_data WHERE attempt_id = '", attempt_id, "'", sep = "")
results <- dbGetQuery(db_pool, query)
return(results)
}
# Example usage
attempts <- check_attempts('online-exam-with-examinr')
print(attempts)
# Replace 'your_attempt_id' with the actual attempt ID
section_data <- check_section_data('e5f02283-65af-4310-8cef-606a25243b17')
print(section_data)
install.packages("base64enc")
library(DBI)
library(pool)
library(base64enc)
# Assuming db_pool is already created as in your code
# Function to check section data
check_section_data <- function(attempt_id) {
query <- paste("SELECT * FROM section_data WHERE attempt_id = '", attempt_id, "'", sep = "")
results <- dbGetQuery(db_pool, query)
return(results)
}
# Retrieve the data
section_data <- check_section_data('e5f02283-65af-4310-8cef-606a25243b17')
# Example of how to decode the data
>>>>>>> 3e3cb9015a535769145051a56fe546a9e0a2a554
decode_data <- function(encoded_data) {
raw_data <- base64decode(encoded_data)
unserialized_data <- unserialize(raw_data)
return(unserialized_data)
}
# Assuming 'section_data$section_data' contains the encoded data
decoded_section_data <- lapply(section_data$section_data, decode_data)
<<<<<<< HEAD
# Print the retrieved and decoded data
print("Attempts Data:")
print(attempts_data)
print("Section Data (Raw):")
print(section_data)
print("Section Data (Decoded):")
print(decoded_section_data)
# Determine all unique column names across all decoded data frames
all_column_names <- unique(unlist(lapply(decoded_section_data, function(x) names(x))))
# Function to pad lists with NAs and standardize column names
pad_and_standardize <- function(x, all_column_names) {
# Convert list to named vector if it's not already
if (is.null(names(x))) {
x <- setNames(as.list(x), all_column_names[1:length(x)])
}
# Ensure all elements have the same columns
result <- setNames(rep(NA, length(all_column_names)), all_column_names)
result[names(x)] <- x
return(result)
}
# Pad and standardize all decoded data frames
standardized_section_data <- lapply(decoded_section_data, pad_and_standardize, all_column_names = all_column_names)
# Convert the standardized decoded section data to a data frame
decoded_section_data_df <- do.call(rbind, lapply(standardized_section_data, function(x) as.data.frame(t(x), stringsAsFactors = FALSE)))
# Combine the data into a single list
combined_data <- list(
Attempts_Data = attempts_data,
Section_Data_Raw = section_data,
Section_Data_Decoded = decoded_section_data_df
)
# Save the data to an Excel file
write_xlsx(combined_data, "exam_data.xlsx")
# Save the data to an Excel file
write_xlsx(combined_data, "exam_data1.xlsx")
# Close the pool of connections when done
poolClose(db_pool)
=======
# Print the decoded data
print(decoded_section_data)
library(DBI)
library(pool)
library(base64enc)
# Assuming db_pool is already created as in your code
# Function to check section data
check_section_data <- function(attempt_id) {
query <- paste("SELECT * FROM section_data WHERE attempt_id = '", attempt_id, "'", sep = "")
results <- dbGetQuery(db_pool, query)
return(results)
}
# Retrieve the data
section_data <- check_section_data('e5f02283-65af-4310-8cef-606a25243b17')
# Example of how to decode the data
decode_data <- function(encoded_data) {
raw_data <- base64decode(encoded_data)
unserialized_data <- unserialize(raw_data)
return(unserialized_data)
}
# Assuming 'section_data$section_data' contains the encoded data
decoded_section_data <- lapply(section_data$section_data, decode_data)
# Print the decoded data
print(decoded_section_data)
# Retrieve data from a specific table
attempts <- dbReadTable(con, "attempts")
# Replace 'your_table_name' with the actual table name you want to view
data <- dbReadTable(con, 'examinr-first_exam')
data <- dbReadTable(con, 'examinr-first_exam.sqlite')
dbDisconnect(con)
library(DBI)
library(pool)
library(base64enc)
# Assuming db_pool is already created as in your code
# Function to check section data
check_section_data <- function(attempt_id) {
query <- paste("SELECT * FROM section_data WHERE attempt_id = '", attempt_id, "'", sep = "")
results <- dbGetQuery(db_pool, query)
return(results)
}
# Retrieve the data
section_data <- check_section_data('e5f02283-65af-4310-8cef-606a25243b17')
# Example of how to decode the data
decode_data <- function(encoded_data) {
raw_data <- base64decode(encoded_data)
unserialized_data <- unserialize(raw_data)
return(unserialized_data)
}
# Assuming 'section_data$section_data' contains the encoded data
decoded_section_data <- lapply(section_data$section_data, decode_data)
# Print the decoded data
print(decoded_section_data)
>>>>>>> 3e3cb9015a535769145051a56fe546a9e0a2a554
getwd()
finish_attempt()
